<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESTV Strategic AI Advisor | Token Simulation Engine</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Light background as requested */
            color: #334155;
        }
        
        /* Custom Scrollbar for sleek look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9; 
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 350px;
            max-height: 400px;
        }

        .slider-track {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 5px;
            background: #e2e8f0;
            outline: none;
        }
        .slider-track::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            transition: background .15s ease-in-out;
        }
        .slider-track::-webkit-slider-thumb:hover {
            background: #4338ca;
        }

        .card-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
        }
    </style>

    <!-- Chosen Palette: Warm Neutrals & Professional Indigo -->
    <!-- Application Structure Plan:
        1. Header: Establish context as an AI Strategy Tool.
        2. Dashboard Layout: 
           - Left/Top: Control Panel (Inputs) - Allows user to define the 'Market Scenario'.
           - Right/Bottom: Real-time Analysis - Immediate feedback loop.
        3. Key Visualization: 
           - Price Trend Simulation (Line Chart) -> Shows the 'Journey'.
           - Outcome Distribution (Bar Chart) -> Shows the 'Risk/Probability'.
        4. Strategic Insight Block: AI-generated text explaining the data, replacing static reports.
        5. Justification: This structure empowers the user to perform "What-if" analysis, transforming static data into a dynamic strategy session.
    -->
    <!-- Visualization & Content Choices:
        - Monte Carlo Chart: Chart.js Line Chart with multiple datasets to show 'Range' vs 'Average'.
        - Success Metrics: Simple Stat Cards for Win Rate & VaR.
        - Interaction: Sliders for input to allow fluid exploration of scenarios without reloading.
        - Logic: JS implementation of the 'TokenSimulationEngine' class described in Python source.
        - CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
</head>
<body class="text-slate-700 antialiased">

    <!-- Top Navigation / Header -->
    <nav class="bg-white border-b border-slate-200 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center gap-3">
                    <div class="bg-indigo-600 text-white p-2 rounded-lg">
                        <i class="fa-solid fa-brain"></i>
                    </div>
                    <div>
                        <h1 class="text-xl font-bold text-slate-900 tracking-tight">ESTV Strategic AI Advisor</h1>
                        <p class="text-xs text-slate-500">Chaos Labs Benchmark Engine v2.5</p>
                    </div>
                </div>
                <div class="flex items-center">
                    <button onclick="resetSimulation()" class="text-sm font-medium text-slate-500 hover:text-indigo-600 transition-colors flex items-center gap-2">
                        <i class="fa-solid fa-rotate-right"></i> 초기화
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        
        <!-- Intro Section -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-slate-900 mb-2">시뮬레이션 대시보드</h2>
            <p class="text-slate-600 max-w-3xl">
                이 AI 분석 도구는 <strong>몬테카를로 시뮬레이션(Monte Carlo Simulation)</strong>을 사용하여 다양한 시장 변수 하에서 ESTV 토큰의 가격 흐름을 예측합니다. 
                매수 유입량, 시장 심리(FOMO/Panic), 유동성 깊이를 조절하여 <strong>목표가 달성 확률</strong>과 <strong>리스크(VaR)</strong>를 실시간으로 분석하십시오.
            </p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            
            <!-- Left Column: Scenario Controls (Inputs) -->
            <div class="lg:col-span-4 space-y-6">
                
                <!-- Input Card -->
                <div class="bg-white rounded-xl card-shadow border border-slate-100 p-6">
                    <div class="flex items-center gap-2 mb-6">
                        <i class="fa-solid fa-sliders text-indigo-500"></i>
                        <h3 class="text-lg font-bold text-slate-800">시나리오 파라미터 설정</h3>
                    </div>

                    <!-- Input: Target Price -->
                    <div class="mb-6">
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700">목표 가격 (Target Price)</label>
                            <span id="val-target" class="text-sm font-bold text-indigo-600">$0.50</span>
                        </div>
                        <input type="range" id="input-target" min="0.1" max="5.0" step="0.1" value="0.5" class="slider-track" oninput="updateValues()">
                        <p class="text-xs text-slate-400 mt-1">성공 확률 계산의 기준이 됩니다.</p>
                    </div>

                    <!-- Input: Monthly Buy Volume -->
                    <div class="mb-6">
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700">월간 매수 유입 (Buy Volume)</label>
                            <span id="val-inflow" class="text-sm font-bold text-indigo-600">50,000 Unit</span>
                        </div>
                        <input type="range" id="input-inflow" min="10000" max="500000" step="5000" value="50000" class="slider-track" oninput="updateValues()">
                        <p class="text-xs text-slate-400 mt-1">마케팅 강도 및 신규 유저 유입을 대변합니다.</p>
                    </div>

                    <!-- Input: Liquidity Strength -->
                    <div class="mb-6">
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700">유동성 깊이 (Liquidity Depth)</label>
                            <span id="val-liquidity" class="text-sm font-bold text-indigo-600">Medium</span>
                        </div>
                        <input type="range" id="input-liquidity" min="1" max="5" step="1" value="3" class="slider-track" oninput="updateValues()">
                        <p class="text-xs text-slate-400 mt-1">1(낮음) ~ 5(매우 높음). 가격 방어력을 의미합니다.</p>
                    </div>

                    <!-- Input: Market Panic/Volatility -->
                    <div class="mb-6">
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700">시장 변동성 (Market Noise)</label>
                            <span id="val-volatility" class="text-sm font-bold text-indigo-600">Normal</span>
                        </div>
                        <input type="range" id="input-volatility" min="0.5" max="2.0" step="0.1" value="1.0" class="slider-track" oninput="updateValues()">
                        <p class="text-xs text-slate-400 mt-1">매도 압력 및 시장 공포(Panic) 민감도입니다.</p>
                    </div>

                    <button onclick="runSimulation()" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all shadow-lg shadow-indigo-200 active:scale-95 flex justify-center items-center gap-2">
                        <i class="fa-solid fa-play"></i> 시뮬레이션 실행 (Run AI)
                    </button>
                </div>

                <!-- Strategic Summary Card -->
                <div class="bg-indigo-50 rounded-xl border border-indigo-100 p-6">
                    <h4 class="text-indigo-900 font-bold mb-3 flex items-center gap-2">
                        <i class="fa-solid fa-robot"></i> AI 전략 요약
                    </h4>
                    <div id="ai-advice-text" class="text-sm text-indigo-800 leading-relaxed space-y-2">
                        <!-- Dynamic Content Will Load Here -->
                        <div class="animate-pulse space-y-2">
                            <div class="h-2 bg-indigo-200 rounded"></div>
                            <div class="h-2 bg-indigo-200 rounded w-5/6"></div>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Right Column: Visualization Dashboard -->
            <div class="lg:col-span-8 space-y-6">
                
                <!-- KPI Cards -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="bg-white p-5 rounded-xl card-shadow border border-slate-100">
                        <p class="text-xs font-semibold text-slate-400 uppercase tracking-wider">성공 확률 (Win Rate)</p>
                        <h3 id="kpi-success" class="text-3xl font-bold text-slate-800 mt-1">--%</h3>
                        <p class="text-xs text-slate-500 mt-2">Target Price 달성 비율</p>
                    </div>
                    <div class="bg-white p-5 rounded-xl card-shadow border border-slate-100">
                        <p class="text-xs font-semibold text-slate-400 uppercase tracking-wider">예상 최종가 (Median)</p>
                        <h3 id="kpi-price" class="text-3xl font-bold text-slate-800 mt-1">$0.00</h3>
                        <p class="text-xs text-slate-500 mt-2">시뮬레이션 중위값</p>
                    </div>
                    <div class="bg-white p-5 rounded-xl card-shadow border border-slate-100">
                        <p class="text-xs font-semibold text-slate-400 uppercase tracking-wider">리스크 (VaR 95%)</p>
                        <h3 id="kpi-risk" class="text-3xl font-bold text-rose-500 mt-1">$0.00</h3>
                        <p class="text-xs text-slate-500 mt-2">최악의 시나리오 (하위 5%)</p>
                    </div>
                </div>

                <!-- Chart 1: Price Trajectory -->
                <div class="bg-white p-6 rounded-xl card-shadow border border-slate-100">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-bold text-slate-800">예상 가격 경로 (365일)</h3>
                        <span class="text-xs bg-slate-100 text-slate-600 px-2 py-1 rounded">Monte Carlo N=50</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="trajectoryChart"></canvas>
                    </div>
                    <p class="text-xs text-slate-400 mt-2 text-center">
                        *회색 영역은 시뮬레이션의 범위, 굵은 선은 중위값 추세를 나타냅니다.
                    </p>
                </div>

                <!-- Chart 2: Success Distribution -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Distribution Chart -->
                    <div class="bg-white p-6 rounded-xl card-shadow border border-slate-100">
                        <h3 class="font-bold text-slate-800 mb-4">최종 가격 분포도</h3>
                        <div class="chart-container" style="height: 250px;">
                            <canvas id="distributionChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Market Sentiment Analysis -->
                    <div class="bg-white p-6 rounded-xl card-shadow border border-slate-100">
                        <h3 class="font-bold text-slate-800 mb-4">시장 민감도 분석</h3>
                        <div class="space-y-4">
                            <div>
                                <div class="flex justify-between text-xs font-medium mb-1">
                                    <span class="text-slate-500">FOMO 강도 (매수 가속)</span>
                                    <span id="metric-fomo" class="text-indigo-600">High</span>
                                </div>
                                <div class="w-full bg-slate-100 rounded-full h-2">
                                    <div id="bar-fomo" class="bg-indigo-500 h-2 rounded-full" style="width: 70%"></div>
                                </div>
                            </div>
                            <div>
                                <div class="flex justify-between text-xs font-medium mb-1">
                                    <span class="text-slate-500">Panic 저항력 (매도 방어)</span>
                                    <span id="metric-panic" class="text-rose-600">Low</span>
                                </div>
                                <div class="w-full bg-slate-100 rounded-full h-2">
                                    <div id="bar-panic" class="bg-rose-400 h-2 rounded-full" style="width: 30%"></div>
                                </div>
                            </div>
                            <div class="bg-slate-50 p-3 rounded border border-slate-100 mt-4">
                                <p id="sensitivity-text" class="text-xs text-slate-600">
                                    현재 유동성 수준에서 대량 매도 발생 시 가격 하락폭이 큽니다. 유동성 공급이 우선입니다.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </main>

    <!-- JavaScript Logic -->
    <script>
        // --- Global State ---
        const state = {
            targetPrice: 0.5,
            buyVolume: 50000,
            liquidityLevel: 3, // 1 to 5
            volatility: 1.0,
            simulationResults: null,
            chartInstances: {}
        };

        // --- Constants mimicking Python Logic ---
        const INITIAL_PRICE = 0.5;
        const DAYS = 365;
        const MONTE_CARLO_ITERATIONS = 50;

        // --- Helper: Format Currency ---
        const fmtUSD = (num) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2 }).format(num);

        // --- Core Simulation Engine (Ported Logic) ---
        function runSingleSimulation() {
            let prices = [INITIAL_PRICE];
            let currentPrice = INITIAL_PRICE;
            
            // Base Liquidity Constant (Simplified AMM Model)
            // Higher liquidity level = Less price impact per volume
            const liquidityConstant = 1000000 * Math.pow(state.liquidityLevel, 1.5); 

            // Panic Sensitivity Base
            let panicFactor = state.volatility;

            for (let day = 1; day <= DAYS; day++) {
                // 1. Daily Volume Noise
                const dailyBuyBase = state.buyVolume / 30;
                const buyNoise = 0.8 + Math.random() * 0.4; // +/- 20%
                const dailyBuy = dailyBuyBase * buyNoise;

                // 2. Sell Pressure (Increases as price rises - Profit taking)
                const profitTakingRatio = Math.max(0.05, (currentPrice - INITIAL_PRICE) / INITIAL_PRICE * 0.1);
                const dailySell = dailyBuy * (0.8 + Math.random() * 0.4) * (1 + profitTakingRatio * panicFactor);

                // 3. Price Impact Calculation (Simplified Constant Product Logic)
                // New Price ~= Old Price * (1 + (Net Flow / Liquidity))
                const netFlow = dailyBuy - dailySell;
                const impact = netFlow / liquidityConstant;
                
                // Add market noise
                const marketNoise = (Math.random() - 0.5) * 0.02 * state.volatility;

                currentPrice = currentPrice * (1 + impact + marketNoise);
                
                // Prevent negative prices
                if(currentPrice < 0.001) currentPrice = 0.001;
                
                prices.push(currentPrice);
            }
            return prices;
        }

        function runMonteCarlo() {
            const allRuns = [];
            const finalPrices = [];
            let successCount = 0;
            let minPrices = [];

            for (let i = 0; i < MONTE_CARLO_ITERATIONS; i++) {
                const run = runSingleSimulation();
                allRuns.push(run);
                const finalP = run[run.length - 1];
                finalPrices.push(finalP);
                minPrices.push(Math.min(...run));

                if (finalP >= state.targetPrice) {
                    successCount++;
                }
            }

            // Calculate Stats
            finalPrices.sort((a, b) => a - b);
            const medianPrice = finalPrices[Math.floor(finalPrices.length / 2)];
            // Value at Risk (5th percentile)
            const varPrice = finalPrices[Math.floor(finalPrices.length * 0.05)]; 

            return {
                runs: allRuns,
                finalPrices: finalPrices,
                medianPrice: medianPrice,
                varPrice: varPrice,
                successRate: (successCount / MONTE_CARLO_ITERATIONS) * 100
            };
        }

        // --- UI Update Functions ---
        function updateValues() {
            state.targetPrice = parseFloat(document.getElementById('input-target').value);
            state.buyVolume = parseInt(document.getElementById('input-inflow').value);
            state.liquidityLevel = parseInt(document.getElementById('input-liquidity').value);
            state.volatility = parseFloat(document.getElementById('input-volatility').value);

            // Update Labels
            document.getElementById('val-target').innerText = fmtUSD(state.targetPrice);
            document.getElementById('val-inflow').innerText = new Intl.NumberFormat('en-US').format(state.buyVolume) + " Unit";
            
            const liqLabels = ["Very Low", "Low", "Medium", "High", "Deep"];
            document.getElementById('val-liquidity').innerText = liqLabels[state.liquidityLevel - 1];
            
            const volLabels = state.volatility < 0.8 ? "Stable" : state.volatility > 1.2 ? "Chaotic" : "Normal";
            document.getElementById('val-volatility').innerText = `${state.volatility} (${volLabels})`;
        }

        function updateAIAdvice(results) {
            const adviceEl = document.getElementById('ai-advice-text');
            const { successRate, varPrice, medianPrice } = results;
            let colorClass = "text-indigo-800";

            // --- What ---
            const what = "이 전략은 ESTV 토큰의 상장 후 1년간 가격 경로와 목표가 달성 확률을 분석합니다.";
            // --- Why ---
            const why = "시장 변동성과 유동성에 따라 투자 리스크와 기회가 크게 달라지기 때문입니다.";
            // --- Summary ---
            const summary = `목표가 달성 확률은 <b>${successRate.toFixed(1)}%</b>이며, 중위값 경로는 <b>${fmtUSD(medianPrice)}</b>입니다.`;

            // --- Body (시나리오별 분석) ---
            let body = "";
            if (successRate >= 80) {
                body = "<b>시나리오1 (강한 매수/유동성):</b> 현재의 매수 유입과 유동성 비율이 이상적입니다. 가격 상승에 따른 이익 실현 매물을 소화할 수 있는 구조입니다.";
            } else if (successRate >= 50) {
                body = `<b>시나리오2 (중립):</b> 목표가 달성 가능성이 반반입니다. 성공 확률을 높이려면 월간 매수 유입을 <b>${(state.buyVolume * 1.2).toLocaleString()}</b> 수준으로 늘리거나, 유동성 풀을 강화하여 변동성을 줄여야 합니다.`;
            } else {
                colorClass = "text-rose-700";
                body = "<b>시나리오3 (리스크):</b> 현재 구조로는 목표가 달성이 어렵습니다. 특히 하방 리스크(VaR)가 큽니다. 공격적인 마케팅보다 유동성 공급(LP) 확충을 통해 가격 하락 방어선을 먼저 구축해야 합니다.";
            }

            // --- 실행권고 ---
            let action = "";
            if (successRate >= 80) {
                action = "현 상태 유지를 권장합니다.";
            } else if (successRate >= 50) {
                action = "마케팅 강화 또는 유동성 풀 확충을 권장합니다.";
            } else {
                action = "유동성 공급(LP) 확충이 필수적입니다.";
            }

            // --- 요약 ---
            const conclusion = (successRate >= 50)
                ? "현 구조에서 목표가 달성 가능성이 있습니다."
                : "추가 유동성 공급 없이는 목표가 달성이 어렵습니다.";

            adviceEl.className = `text-sm leading-relaxed ${colorClass}`;
            adviceEl.innerHTML = `
                <b>What:</b> ${what}<br>
                <b>Why:</b> ${why}<br>
                <b>Summary:</b> ${summary}<br>
                <b>Body:</b> ${body}<br>
                <b>실행권고:</b> ${action}<br>
                <b>요약:</b> ${conclusion}
            `;

            // Update Sensitivity Bars
            const fomoWidth = Math.min(100, (state.buyVolume / 5000) * (state.volatility));
            const panicWidth = Math.max(10, 100 - (state.liquidityLevel * 20));
            document.getElementById('bar-fomo').style.width = `${fomoWidth}%`;
            document.getElementById('bar-panic').style.width = `${panicWidth}%`;
            document.getElementById('metric-fomo').innerText = fomoWidth > 70 ? "High" : "Moderate";
            document.getElementById('metric-panic').innerText = panicWidth > 60 ? "Vulnerable" : "Secure";
            // Sensitivity Text
            const sensText = document.getElementById('sensitivity-text');
            if (panicWidth > 60) {
                sensText.innerText = "유동성이 얕아 적은 매도세에도 가격이 급락할 위험이 있습니다 (High Slippage Risk).";
                sensText.className = "text-xs text-rose-600";
            } else {
                sensText.innerText = "유동성이 충분하여 고래의 매도 압력을 견딜 수 있는 구조입니다.";
                sensText.className = "text-xs text-emerald-600";
            }
        }

        function drawCharts(results) {
            const ctxTrajectory = document.getElementById('trajectoryChart').getContext('2d');
            const ctxDistribution = document.getElementById('distributionChart').getContext('2d');

            // --- Chart 1: Trajectory ---
            // Prepare datasets: Show Median run, Best run, Worst run
            const labels = Array.from({length: DAYS}, (_, i) => `Day ${i+1}`);

            // Sort runs by final price to pick representative paths
            const sortedRuns = [...results.runs].sort((a, b) => a[DAYS-1] - b[DAYS-1]);
            const medianRun = sortedRuns[Math.floor(sortedRuns.length / 2)];
            const bestRun = sortedRuns[sortedRuns.length - 1];
            const worstRun = sortedRuns[0];

            // --- Y축 자동 줌아웃 계산 ---
            const allPrices = [].concat(...results.runs);
            const minY = Math.min(...allPrices) * 0.95;
            const maxY = Math.max(...allPrices) * 1.05;

            if (state.chartInstances.trajectory) state.chartInstances.trajectory.destroy();

            state.chartInstances.trajectory = new Chart(ctxTrajectory, {
                type: 'line',
                data: {
                    labels: labels.filter((_, i) => i % 30 === 0), // Show monthly labels
                    datasets: [
                        {
                            label: 'Median Path (중위값)',
                            data: medianRun.filter((_, i) => i % 30 === 0),
                            borderColor: '#4f46e5', // Indigo 600
                            borderWidth: 3,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        {
                            label: 'Best Scenario',
                            data: bestRun.filter((_, i) => i % 30 === 0),
                            borderColor: '#10b981', // Emerald 500
                            borderWidth: 1,
                            borderDash: [5, 5],
                            tension: 0.4,
                            pointRadius: 0,
                            fill: false
                        },
                        {
                            label: 'Worst Scenario',
                            data: worstRun.filter((_, i) => i % 30 === 0),
                            borderColor: '#f43f5e', // Rose 500
                            borderWidth: 1,
                            borderDash: [5, 5],
                            tension: 0.4,
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index',
                    },
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + fmtUSD(context.raw);
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            suggestedMin: minY,
                            suggestedMax: maxY,
                            grid: { color: '#f1f5f9' },
                            ticks: { callback: (val) => '$' + val }
                        },
                        x: { grid: { display: false } }
                    }
                }
            });

            // --- Chart 2: Distribution Histogram ---
            // Bucketing prices
            const prices = results.finalPrices;
            const minP = Math.floor(Math.min(...prices) * 10) / 10;
            const maxP = Math.ceil(Math.max(...prices) * 10) / 10;
            const bucketSize = (maxP - minP) / 10 || 0.1;
            
            const buckets = new Array(10).fill(0);
            const bucketLabels = [];
            
            for(let i=0; i<10; i++) {
                const start = minP + (i * bucketSize);
                const end = start + bucketSize;
                bucketLabels.push(`${start.toFixed(2)} - ${end.toFixed(2)}`);
            }

            prices.forEach(p => {
                let idx = Math.floor((p - minP) / bucketSize);
                if (idx >= 10) idx = 9;
                buckets[idx]++;
            });

            // Highlight target bucket
            const bgColors = bucketLabels.map(label => {
                const rangeStart = parseFloat(label.split(' - ')[0]);
                return rangeStart >= state.targetPrice ? '#10b981' : '#cbd5e1'; // Green if above target
            });

            if (state.chartInstances.distribution) state.chartInstances.distribution.destroy();

            state.chartInstances.distribution = new Chart(ctxDistribution, {
                type: 'bar',
                data: {
                    labels: bucketLabels,
                    datasets: [{
                        label: 'Frequency',
                        data: buckets,
                        backgroundColor: bgColors,
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (items) => `Range: $${items[0].label}`
                            }
                        }
                    },
                    scales: {
                        y: { display: false },
                        x: { 
                            grid: { display: false },
                            ticks: { font: { size: 10 } }
                        }
                    }
                }
            });
        }

        function runSimulation() {
            // Show Loading State (Optional visual flair)
            const btn = document.querySelector('button[onclick="runSimulation()"]');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> 계산 중...';
            btn.disabled = true;

            setTimeout(() => {
                const results = runMonteCarlo();
                state.simulationResults = results;

                // Update UI Numbers
                document.getElementById('kpi-success').innerText = results.successRate.toFixed(1) + '%';
                document.getElementById('kpi-success').className = `text-3xl font-bold mt-1 ${results.successRate >= 50 ? 'text-emerald-600' : 'text-rose-500'}`;
                
                document.getElementById('kpi-price').innerText = fmtUSD(results.medianPrice);
                document.getElementById('kpi-risk').innerText = fmtUSD(results.varPrice);

                // Update Text & Charts
                updateAIAdvice(results);
                drawCharts(results);

                // Reset Button
                btn.innerHTML = originalText;
                btn.disabled = false;
            }, 500); // Artificial delay for UX
        }

        function resetSimulation() {
            document.getElementById('input-target').value = 0.5;
            document.getElementById('input-inflow').value = 50000;
            document.getElementById('input-liquidity').value = 3;
            document.getElementById('input-volatility').value = 1.0;
            updateValues();
            runSimulation();
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            updateValues();
            runSimulation();
        });

    </script>
</body>
</html>